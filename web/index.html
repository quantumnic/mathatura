<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mathatura â€” Mathematical Beauty in Nature</title>
<style>
:root {
  --bg: #0a0a1a;
  --bg2: #12122a;
  --bg3: #1a1a3e;
  --text: #e0e0f0;
  --text2: #8888aa;
  --accent: #6c63ff;
  --accent2: #ff6b9d;
  --gold: #ffd700;
  --green: #4ecdc4;
  --sidebar-w: 280px;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family: 'Segoe UI',system-ui,-apple-system,sans-serif; background:var(--bg); color:var(--text); display:flex; height:100vh; overflow:hidden; }

/* Sidebar */
.sidebar { width:var(--sidebar-w); background:var(--bg2); border-right:1px solid #222244; display:flex; flex-direction:column; flex-shrink:0; }
.sidebar-header { padding:20px; border-bottom:1px solid #222244; }
.sidebar-header h1 { font-size:1.5rem; background:linear-gradient(135deg,var(--accent),var(--accent2),var(--gold)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; letter-spacing:1px; }
.sidebar-header p { font-size:0.75rem; color:var(--text2); margin-top:4px; }
.search-box { margin:12px 16px; padding:8px 12px; background:var(--bg3); border:1px solid #333355; border-radius:8px; color:var(--text); font-size:0.85rem; outline:none; width:calc(100% - 32px); }
.search-box:focus { border-color:var(--accent); }
.filters { display:flex; gap:6px; padding:0 16px 12px; flex-wrap:wrap; }
.filter-btn { padding:3px 10px; border-radius:12px; border:1px solid #333355; background:transparent; color:var(--text2); font-size:0.7rem; cursor:pointer; transition:all .2s; }
.filter-btn:hover, .filter-btn.active { background:var(--accent); color:white; border-color:var(--accent); }
.nav { flex:1; overflow-y:auto; padding:8px 0; }
.nav-item { display:flex; align-items:center; gap:10px; padding:10px 16px; cursor:pointer; transition:all .15s; border-left:3px solid transparent; }
.nav-item:hover { background:var(--bg3); }
.nav-item.active { background:var(--bg3); border-left-color:var(--accent); }
.nav-icon { font-size:1.2rem; width:28px; text-align:center; }
.nav-label { font-size:0.85rem; }
.nav-badge { margin-left:auto; font-size:0.6rem; padding:2px 6px; border-radius:8px; background:var(--bg); }
.badge-kids { color:#4ecdc4; border:1px solid #4ecdc4; }
.badge-teens { color:#ffd700; border:1px solid #ffd700; }
.badge-uni { color:#ff6b6b; border:1px solid #ff6b6b; }

/* Main content */
.main { flex:1; display:flex; flex-direction:column; overflow:hidden; }
.content-header { padding:20px 30px 0; }
.content-header h2 { font-size:1.6rem; margin-bottom:4px; }
.content-header .subtitle { color:var(--text2); font-size:0.9rem; }
.content-body { flex:1; overflow-y:auto; padding:20px 30px; display:flex; flex-direction:column; gap:20px; }

/* Canvas area */
.canvas-wrap { position:relative; background:var(--bg2); border-radius:12px; border:1px solid #222244; overflow:hidden; cursor:grab; }
.canvas-wrap.panning { cursor:grabbing; }
canvas { display:block; width:100%; height:auto; touch-action:none; }

/* Zoom indicator */
.zoom-indicator {
  position:absolute; top:12px; right:12px;
  background:rgba(10,10,26,0.85); border:1px solid #333355;
  border-radius:8px; padding:6px 12px;
  font-size:0.75rem; font-family:monospace;
  color:var(--green); pointer-events:none;
  transition: opacity 0.3s;
  z-index:10;
}
.zoom-controls {
  position:absolute; bottom:12px; right:12px;
  display:flex; gap:4px; z-index:10;
}
.zoom-btn {
  width:32px; height:32px; border-radius:6px;
  background:rgba(10,10,26,0.85); border:1px solid #333355;
  color:var(--text); font-size:1rem; cursor:pointer;
  display:flex; align-items:center; justify-content:center;
  transition:all .2s;
}
.zoom-btn:hover { background:var(--accent); border-color:var(--accent); }
.zoom-hint {
  position:absolute; bottom:12px; left:12px;
  background:rgba(10,10,26,0.7); border:1px solid #222244;
  border-radius:6px; padding:4px 8px;
  font-size:0.65rem; color:var(--text2);
  pointer-events:none; z-index:10;
}

/* Controls */
.controls { background:var(--bg2); border-radius:12px; border:1px solid #222244; padding:20px; }
.controls h3 { font-size:0.9rem; color:var(--accent); margin-bottom:12px; text-transform:uppercase; letter-spacing:1px; }
.control-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(240px,1fr)); gap:16px; }
.control-item label { display:block; font-size:0.8rem; color:var(--text2); margin-bottom:4px; }
.control-item input[type=range] { width:100%; accent-color:var(--accent); }
.control-item .value { font-size:0.75rem; color:var(--accent); float:right; }
.control-item select { width:100%; padding:6px 10px; background:var(--bg3); border:1px solid #333355; border-radius:6px; color:var(--text); font-size:0.85rem; }
.btn-row { display:flex; gap:8px; margin-top:12px; }
.btn { padding:8px 16px; border-radius:8px; border:none; cursor:pointer; font-size:0.8rem; font-weight:600; transition:all .2s; }
.btn-primary { background:var(--accent); color:white; }
.btn-primary:hover { background:#5a52e0; }
.btn-secondary { background:var(--bg3); color:var(--text); border:1px solid #333355; }

/* Info panel */
.info-panel { background:var(--bg2); border-radius:12px; border:1px solid #222244; padding:20px; }
.info-panel h3 { font-size:0.9rem; color:var(--gold); margin-bottom:8px; }
.info-panel p { font-size:0.85rem; line-height:1.6; color:var(--text2); }
.info-panel .math { font-family:'Courier New',monospace; color:var(--green); background:var(--bg); padding:2px 6px; border-radius:4px; font-size:0.8rem; }
.formula-block { background:var(--bg); padding:12px 16px; border-radius:8px; margin:10px 0; font-family:'Courier New',monospace; color:var(--green); font-size:0.85rem; line-height:1.8; }
.nature-examples { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
.nature-tag { padding:4px 10px; background:var(--bg); border-radius:12px; font-size:0.75rem; color:var(--text2); border:1px solid #222244; }

/* Knowledge Links */
.knowledge-panel { background:var(--bg2); border-radius:12px; border:1px solid #222244; padding:20px; }
.knowledge-panel h3 { font-size:0.9rem; color:var(--accent2); margin-bottom:14px; text-transform:uppercase; letter-spacing:1px; }
.knowledge-group { margin-bottom:14px; }
.knowledge-group:last-child { margin-bottom:0; }
.knowledge-group-title { font-size:0.75rem; color:var(--text2); text-transform:uppercase; letter-spacing:1px; margin-bottom:8px; padding-bottom:4px; border-bottom:1px solid #222244; }
.knowledge-link {
  display:flex; align-items:flex-start; gap:10px; padding:8px 12px;
  background:var(--bg); border-radius:8px; margin-bottom:6px;
  text-decoration:none; color:var(--text); transition:all .2s;
  border:1px solid transparent;
}
.knowledge-link:hover { border-color:var(--accent); background:var(--bg3); }
.knowledge-link .kl-icon { font-size:1.1rem; flex-shrink:0; margin-top:1px; }
.knowledge-link .kl-info { flex:1; min-width:0; }
.knowledge-link .kl-title { font-size:0.82rem; font-weight:600; color:var(--text); }
.knowledge-link .kl-desc { font-size:0.72rem; color:var(--text2); margin-top:2px; line-height:1.4; }
.knowledge-link .kl-arrow { color:var(--text2); font-size:0.8rem; margin-top:2px; transition:all .2s; }
.knowledge-link:hover .kl-arrow { color:var(--accent); transform:translateX(2px); }

/* Scrollbar */
::-webkit-scrollbar { width:6px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:#333355; border-radius:3px; }
::-webkit-scrollbar-thumb:hover { background:#444466; }

/* Stats bar */
.stats-bar { display:flex; gap:20px; padding:12px 0; flex-wrap:wrap; }
.stat { text-align:center; }
.stat-value { font-size:1.3rem; font-weight:700; color:var(--accent); }
.stat-label { font-size:0.65rem; color:var(--text2); text-transform:uppercase; letter-spacing:0.5px; }
</style>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <h1>âœ¦ Mathatura</h1>
    <p>Mathematical Beauty in Nature</p>
  </div>
  <input class="search-box" type="text" placeholder="Search topics..." id="search" oninput="filterNav()">
  <div class="filters">
    <button class="filter-btn active" onclick="setFilter('all',this)">All</button>
    <button class="filter-btn" onclick="setFilter('kids',this)">ğŸŸ¢ Kids</button>
    <button class="filter-btn" onclick="setFilter('teens',this)">ğŸŸ¡ Teens</button>
    <button class="filter-btn" onclick="setFilter('uni',this)">ğŸ”´ University</button>
  </div>
  <div class="nav" id="nav"></div>
</div>

<div class="main">
  <div class="content-header" id="content-header">
    <h2 id="title">Welcome to Mathatura</h2>
    <p class="subtitle" id="subtitle">Select a topic from the sidebar to explore</p>
  </div>
  <div class="content-body" id="content-body">
    <div class="canvas-wrap" id="canvas-wrap">
      <canvas id="canvas" width="900" height="600"></canvas>
      <div class="zoom-indicator" id="zoom-indicator">ğŸ” 1.0Ã—</div>
      <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()" title="Zoom in">+</button>
        <button class="zoom-btn" onclick="zoomOut()" title="Zoom out">âˆ’</button>
        <button class="zoom-btn" onclick="resetView()" title="Reset view">âŒ‚</button>
      </div>
      <div class="zoom-hint" id="zoom-hint">Scroll to zoom Â· Drag to pan Â· Double-click to reset</div>
    </div>
    <div class="controls" id="controls"></div>
    <div class="info-panel" id="info"></div>
    <div class="knowledge-panel" id="knowledge" style="display:none;"></div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Category definitions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const categories = [
  { id:'phyllotaxis', icon:'ğŸŒ»', label:'Phyllotaxis', difficulty:'kids',
    subtitle:'How sunflowers pack seeds using the golden angle' },
  { id:'fractals_fern', icon:'ğŸŒ¿', label:'Barnsley Fern', difficulty:'teens',
    subtitle:'A fern from four simple transformations' },
  { id:'fractals_koch', icon:'â„ï¸', label:'Koch Snowflake', difficulty:'kids',
    subtitle:'Infinite perimeter, finite area' },
  { id:'fractals_mandelbrot', icon:'ğŸ”®', label:'Mandelbrot Set', difficulty:'uni',
    subtitle:'The most complex object in mathematics' },
  { id:'spirals', icon:'ğŸš', label:'Spirals', difficulty:'kids',
    subtitle:'From nautilus shells to galaxies' },
  { id:'chaos_lorenz', icon:'ğŸ¦‹', label:'Lorenz Attractor', difficulty:'uni',
    subtitle:'The butterfly that started chaos theory' },
  { id:'chaos_logistic', icon:'ğŸ“ˆ', label:'Logistic Map', difficulty:'teens',
    subtitle:'From order to chaos in one equation' },
  { id:'lsystem', icon:'ğŸŒ³', label:'L-System Trees', difficulty:'teens',
    subtitle:'Growing trees from simple grammars' },
  { id:'turing', icon:'ğŸ†', label:'Turing Patterns', difficulty:'uni',
    subtitle:'How leopards get their spots' },
  { id:'tessellation', icon:'ğŸ¯', label:'Tessellations', difficulty:'kids',
    subtitle:'Why bees chose hexagons' },
  { id:'fibonacci', icon:'ğŸ”¢', label:'Fibonacci Spiral', difficulty:'kids',
    subtitle:'The golden rectangle spiral' },
  { id:'symmetry', icon:'ğŸ¦‹', label:'Symmetry', difficulty:'kids',
    subtitle:'Bilateral, radial, and rotational patterns' },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Navigation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let currentFilter = 'all';
let currentCat = null;

function buildNav() {
  const nav = document.getElementById('nav');
  nav.innerHTML = '';
  const q = document.getElementById('search').value.toLowerCase();
  categories.forEach(c => {
    if (currentFilter !== 'all' && c.difficulty !== currentFilter) return;
    if (q && !c.label.toLowerCase().includes(q) && !c.subtitle.toLowerCase().includes(q)) return;
    const div = document.createElement('div');
    div.className = 'nav-item' + (currentCat === c.id ? ' active' : '');
    const badgeClass = c.difficulty === 'kids' ? 'badge-kids' : c.difficulty === 'teens' ? 'badge-teens' : 'badge-uni';
    div.innerHTML = `<span class="nav-icon">${c.icon}</span><span class="nav-label">${c.label}</span><span class="nav-badge ${badgeClass}">${c.difficulty === 'kids' ? 'ğŸŸ¢' : c.difficulty === 'teens' ? 'ğŸŸ¡' : 'ğŸ”´'}</span>`;
    div.onclick = () => loadCategory(c.id);
    nav.appendChild(div);
  });
}

function setFilter(f, btn) {
  currentFilter = f;
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  buildNav();
}
function filterNav() { buildNav(); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Zoom & Pan System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let viewZoom = 1.0;
let viewPanX = 0;
let viewPanY = 0;
const MIN_ZOOM = 0.1;
const MAX_ZOOM = 10;

// Pan state
let isPanning = false;
let panStartX = 0, panStartY = 0;
let panStartViewX = 0, panStartViewY = 0;

// Touch state
let lastTouchDist = 0;
let lastTouchMidX = 0, lastTouchMidY = 0;
let touchPanning = false;

function updateZoomIndicator() {
  const el = document.getElementById('zoom-indicator');
  if (el) el.textContent = `ğŸ” ${viewZoom.toFixed(1)}Ã—`;
}

function resetView() {
  viewZoom = 1.0;
  viewPanX = 0;
  viewPanY = 0;
  updateZoomIndicator();
  draw();
}

function zoomIn() {
  viewZoom = Math.min(MAX_ZOOM, viewZoom * 1.3);
  updateZoomIndicator();
  draw();
}

function zoomOut() {
  viewZoom = Math.max(MIN_ZOOM, viewZoom / 1.3);
  updateZoomIndicator();
  draw();
}

function applyViewTransform() {
  ctx.save();
  ctx.translate(ctx.w / 2, ctx.h / 2);
  ctx.scale(viewZoom, viewZoom);
  ctx.translate(-ctx.w / 2 + viewPanX, -ctx.h / 2 + viewPanY);
}

function restoreViewTransform() {
  ctx.restore();
}

// Mouse wheel zoom
const canvasWrap = document.getElementById('canvas-wrap');
canvasWrap.addEventListener('wheel', function(e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // Convert mouse position to canvas coordinates
  const canvasX = (mouseX / rect.width) * ctx.w;
  const canvasY = (mouseY / rect.height) * ctx.h;

  const oldZoom = viewZoom;
  const zoomFactor = e.deltaY < 0 ? 1.08 : 1 / 1.08;
  viewZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewZoom * zoomFactor));

  // Adjust pan to zoom toward mouse position
  const zoomChange = viewZoom / oldZoom;
  const cx = ctx.w / 2, cy = ctx.h / 2;
  // Point in world coords under cursor: worldX = (canvasX - cx)/oldZoom + cx - panX
  // We want same point under cursor after zoom
  viewPanX = viewPanX - (canvasX - cx) * (1/viewZoom - 1/oldZoom);
  viewPanY = viewPanY - (canvasY - cy) * (1/viewZoom - 1/oldZoom);

  updateZoomIndicator();
  draw();
}, { passive: false });

// Mouse drag pan
canvas.addEventListener('mousedown', function(e) {
  if (e.button !== 0) return;
  isPanning = true;
  panStartX = e.clientX;
  panStartY = e.clientY;
  panStartViewX = viewPanX;
  panStartViewY = viewPanY;
  canvasWrap.classList.add('panning');
  e.preventDefault();
});

window.addEventListener('mousemove', function(e) {
  if (!isPanning) return;
  const rect = canvas.getBoundingClientRect();
  const dx = (e.clientX - panStartX) / rect.width * ctx.w / viewZoom;
  const dy = (e.clientY - panStartY) / rect.height * ctx.h / viewZoom;
  viewPanX = panStartViewX + dx;
  viewPanY = panStartViewY + dy;
  draw();
});

window.addEventListener('mouseup', function() {
  isPanning = false;
  canvasWrap.classList.remove('panning');
});

// Double-click to reset
canvas.addEventListener('dblclick', function(e) {
  e.preventDefault();
  resetView();
});

// Touch support
canvas.addEventListener('touchstart', function(e) {
  if (e.touches.length === 1) {
    touchPanning = true;
    panStartX = e.touches[0].clientX;
    panStartY = e.touches[0].clientY;
    panStartViewX = viewPanX;
    panStartViewY = viewPanY;
  } else if (e.touches.length === 2) {
    touchPanning = false;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    lastTouchMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    lastTouchMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    panStartViewX = viewPanX;
    panStartViewY = viewPanY;
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchmove', function(e) {
  if (e.touches.length === 1 && touchPanning) {
    const rect = canvas.getBoundingClientRect();
    const dx = (e.touches[0].clientX - panStartX) / rect.width * ctx.w / viewZoom;
    const dy = (e.touches[0].clientY - panStartY) / rect.height * ctx.h / viewZoom;
    viewPanX = panStartViewX + dx;
    viewPanY = panStartViewY + dy;
    draw();
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (lastTouchDist > 0) {
      const scale = dist / lastTouchDist;
      viewZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewZoom * scale));
      updateZoomIndicator();
    }
    lastTouchDist = dist;

    // Also pan with two fingers
    const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    const rect = canvas.getBoundingClientRect();
    viewPanX += (midX - lastTouchMidX) / rect.width * ctx.w / viewZoom;
    viewPanY += (midY - lastTouchMidY) / rect.height * ctx.h / viewZoom;
    lastTouchMidX = midX;
    lastTouchMidY = midY;

    draw();
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', function(e) {
  if (e.touches.length < 2) lastTouchDist = 0;
  if (e.touches.length === 0) touchPanning = false;
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Canvas & Animation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let animId = null;
let params = {};

function resize() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 600 * dpr;
  canvas.style.height = '600px';
  ctx.scale(dpr, dpr);
  ctx.w = rect.width;
  ctx.h = 600;
  if (currentCat) draw();
}
window.addEventListener('resize', resize);

function clear() {
  // Clear the entire canvas (ignoring transform) then re-apply
  ctx.save();
  ctx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Phyllotaxis
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawPhyllotaxis() {
  clear();
  applyViewTransform();
  const n = params.count || 500;
  const angle = (params.angle || 137.508) * Math.PI / 180;
  const scale = params.scale || 4;
  const cx = ctx.w / 2, cy = ctx.h / 2;
  const colorScheme = params.colorScheme || 'spiral';

  for (let i = 0; i < n; i++) {
    const theta = i * angle;
    const r = scale * Math.sqrt(i);
    const x = cx + r * Math.cos(theta);
    const y = cy + r * Math.sin(theta);
    const t = i / n;
    const size = 2 + t * 4;
    let hue;
    if (colorScheme === 'spiral') hue = (theta * 180 / Math.PI * 0.3) % 360;
    else if (colorScheme === 'radius') hue = t * 300;
    else if (colorScheme === 'fibonacci') {
      const arm = Math.round(theta / (2 * Math.PI * 1.618033988749895)) % 8;
      hue = arm * 45;
    } else hue = 45;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fillStyle = `hsl(${hue},${70+t*20}%,${45+t*15}%)`;
    ctx.fill();
  }

  // Draw stats
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.font = '12px monospace';
  ctx.fillText(`n=${n}  angle=${(params.angle||137.508).toFixed(3)}Â°`, 10, ctx.h - 10);
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Barnsley Fern
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawFern() {
  clear();
  applyViewTransform();
  const n = params.iterations || 50000;
  let x = 0, y = 0;
  const pts = [];
  let seed = 42;
  const rand = () => { seed = (seed * 1103515245 + 12345) & 0x7fffffff; return seed / 0x7fffffff; };
  const transforms = [
    { a:0, b:0, c:0, d:0.16, e:0, f:0, p:0.01 },
    { a:0.85, b:0.04, c:-0.04, d:0.85, e:0, f:1.6, p:0.85 },
    { a:params.fern_a2||0.2, b:params.fern_b2||-0.26, c:0.23, d:0.22, e:0, f:1.6, p:0.07 },
    { a:params.fern_a3||-0.15, b:params.fern_b3||0.28, c:0.26, d:0.24, e:0, f:0.44, p:0.07 },
  ];
  for (let i = 0; i < n; i++) {
    const r = rand();
    let cum = 0, t = transforms[0];
    for (const tr of transforms) { cum += tr.p; if (r < cum) { t = tr; break; } }
    const nx = t.a * x + t.b * y + t.e;
    const ny = t.c * x + t.d * y + t.f;
    x = nx; y = ny;
    pts.push({x, y});
  }
  const sx = ctx.w / 6;
  const sy = ctx.h / 11;
  for (const p of pts) {
    const px = ctx.w/2 + p.x * sx;
    const py = ctx.h - p.y * sy - 10;
    const green = 100 + Math.floor(p.y / 10 * 155);
    ctx.fillStyle = `rgb(30,${green},50)`;
    ctx.fillRect(px, py, 1.2, 1.2);
  }
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Koch Snowflake
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawKoch() {
  clear();
  applyViewTransform();
  const iter = Math.min(params.koch_iter || 4, 7);
  const s = Math.min(ctx.w, ctx.h) * 0.7;
  const h = s * Math.sqrt(3) / 2;
  const cx = ctx.w / 2, cy = ctx.h / 2;
  let pts = [
    {x:cx, y:cy - h*2/3},
    {x:cx + s/2, y:cy + h/3},
    {x:cx - s/2, y:cy + h/3},
    {x:cx, y:cy - h*2/3},
  ];
  for (let it = 0; it < iter; it++) {
    const np = [];
    for (let i = 0; i < pts.length - 1; i++) {
      const p1 = pts[i], p2 = pts[i+1];
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const a = p1;
      const b = {x:p1.x+dx/3, y:p1.y+dy/3};
      const d = {x:p1.x+2*dx/3, y:p1.y+2*dy/3};
      const c = {
        x: b.x + dx/3*Math.cos(Math.PI/3) - dy/3*Math.sin(Math.PI/3),
        y: b.y + dx/3*Math.sin(Math.PI/3) + dy/3*Math.cos(Math.PI/3),
      };
      np.push(a,b,c,d);
    }
    np.push(pts[pts.length-1]);
    pts = np;
  }
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
  const grad = ctx.createLinearGradient(0,0,ctx.w,ctx.h);
  grad.addColorStop(0, '#4fc3f7');
  grad.addColorStop(0.5, '#81d4fa');
  grad.addColorStop(1, '#b3e5fc');
  ctx.strokeStyle = grad;
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.fillStyle = 'rgba(79,195,247,0.05)';
  ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '11px monospace';
  ctx.fillText(`iterations=${iter}  segments=${pts.length-1}  rel.perimeter=${(Math.pow(4/3,iter)).toFixed(2)}Ã—`, 10, ctx.h-10);
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Mandelbrot Set
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawMandelbrot() {
  clear();
  // Mandelbrot uses putImageData which ignores transforms, so we handle zoom differently
  const maxIter = params.mandel_iter || 80;
  const zoom = (params.mandel_zoom || 1) * viewZoom;
  const cx = (params.mandel_cx || -0.5) - viewPanX / ctx.w * 2 / (params.mandel_zoom || 1);
  const cy = (params.mandel_cy || 0) - viewPanY / ctx.h * 2 / (params.mandel_zoom || 1);
  const w = ctx.w, h = ctx.h;
  const imgData = ctx.createImageData(w, h);
  const aspect = w / h;
  const rangeY = 2 / zoom;
  const rangeX = rangeY * aspect;

  for (let px = 0; px < w; px++) {
    for (let py = 0; py < h; py++) {
      const x0 = cx + (px / w - 0.5) * rangeX;
      const y0 = cy + (py / h - 0.5) * rangeY;
      let x = 0, y = 0, i = 0;
      while (x*x + y*y <= 4 && i < maxIter) {
        const t = x*x - y*y + x0;
        y = 2*x*y + y0;
        x = t;
        i++;
      }
      const idx = (py * w + px) * 4;
      if (i === maxIter) {
        imgData.data[idx] = 10;
        imgData.data[idx+1] = 10;
        imgData.data[idx+2] = 26;
      } else {
        const t = i / maxIter;
        const smooth = i + 1 - Math.log2(Math.log2(x*x + y*y));
        const st = smooth / maxIter;
        imgData.data[idx] = Math.floor(9*(1-st)*st*st*st*255);
        imgData.data[idx+1] = Math.floor(15*(1-st)*(1-st)*st*st*255);
        imgData.data[idx+2] = Math.floor(8.5*(1-st)*(1-st)*(1-st)*st*255 + 80);
      }
      imgData.data[idx+3] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Spirals
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawSpirals() {
  clear();
  applyViewTransform();
  const type = params.spiral_type || 'golden';
  const turns = params.spiral_turns || 6;
  const nPts = params.spiral_pts || 2000;
  const phi = 1.618033988749895;
  const cx = ctx.w/2, cy = ctx.h/2;
  const maxTheta = turns * 2 * Math.PI;
  const pts = [];

  for (let i = 0; i < nPts; i++) {
    const t = i / nPts;
    const theta = t * maxTheta;
    let r;
    if (type === 'logarithmic') r = 2 * Math.exp(0.12 * theta);
    else if (type === 'archimedean') r = 3 * theta;
    else if (type === 'fermat') r = 15 * Math.sqrt(theta);
    else r = 2 * Math.exp(Math.log(phi) / (Math.PI/2) * theta);
    pts.push({x:cx+r*Math.cos(theta), y:cy+r*Math.sin(theta), t, theta});
  }
  ctx.save();
  ctx.beginPath();
  ctx.rect(-ctx.w, -ctx.h, ctx.w*3, ctx.h*3);
  ctx.clip();
  ctx.beginPath();
  let started = false;
  for (const p of pts) {
    if (p.x < -500 || p.x > ctx.w+500 || p.y < -500 || p.y > ctx.h+500) { started=false; continue; }
    if (!started) { ctx.moveTo(p.x,p.y); started=true; }
    else ctx.lineTo(p.x,p.y);
  }
  const colors = {golden:'#ffd700',logarithmic:'#e91e63',archimedean:'#2196f3',fermat:'#4caf50'};
  ctx.strokeStyle = colors[type] || '#ffd700';
  ctx.lineWidth = 2;
  ctx.shadowColor = colors[type] || '#ffd700';
  ctx.shadowBlur = 8;
  ctx.stroke();
  ctx.restore();
  if (type === 'golden' || type === 'logarithmic') {
    ctx.beginPath();
    started = false;
    for (const p of pts) {
      const mx = 2*cx - p.x, my = 2*cy - p.y;
      if (mx < -500||mx>ctx.w+500||my<-500||my>ctx.h+500) { started=false; continue; }
      if (!started) { ctx.moveTo(mx,my); started=true; }
      else ctx.lineTo(mx,my);
    }
    ctx.strokeStyle = (colors[type]||'#ffd700') + '88';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Lorenz Attractor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawLorenz() {
  clear();
  applyViewTransform();
  const sigma = params.lorenz_sigma || 10;
  const rho = params.lorenz_rho || 28;
  const beta = params.lorenz_beta || 2.667;
  const steps = params.lorenz_steps || 20000;
  const dt = 0.005;
  let x=1,y=1,z=1;
  const pts = [];
  for (let i=0;i<steps;i++) {
    const dx = sigma*(y-x);
    const dy = x*(rho-z)-y;
    const dz = x*y-beta*z;
    x+=dx*dt; y+=dy*dt; z+=dz*dt;
    pts.push({x,y:z,t:i/steps});
  }
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(const p of pts){minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);}
  const sx=(ctx.w-80)/(maxX-minX),sy=(ctx.h-80)/(maxY-minY);
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const px=40+(pts[i].x-minX)*sx;
    const py=ctx.h-40-(pts[i].y-minY)*sy;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.strokeStyle='rgba(255,107,107,0.4)';
  ctx.lineWidth=0.5;
  ctx.stroke();
  for(let i=1;i<pts.length;i+=3){
    const px=40+(pts[i].x-minX)*sx;
    const py=ctx.h-40-(pts[i].y-minY)*sy;
    const hue=pts[i].t*300;
    ctx.fillStyle=`hsla(${hue},80%,60%,0.6)`;
    ctx.fillRect(px-0.5,py-0.5,1,1);
  }
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Logistic Map / Bifurcation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawLogistic() {
  clear();
  applyViewTransform();
  const rMin = params.logistic_rmin || 2.5;
  const rMax = params.logistic_rmax || 4.0;
  const warmup = 200;
  const samples = 100;
  const w = ctx.w, h = ctx.h;

  ctx.fillStyle = 'rgba(108,99,255,0.15)';
  for (let px = 0; px < w; px++) {
    const r = rMin + (rMax - rMin) * px / w;
    let x = 0.5;
    for (let i = 0; i < warmup; i++) x = r * x * (1 - x);
    for (let i = 0; i < samples; i++) {
      x = r * x * (1 - x);
      const py = h - (x * h);
      ctx.fillRect(px, py, 1.5, 1.5);
    }
  }
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = '11px monospace';
  ctx.fillText(`r = ${rMin.toFixed(1)}`, 10, ctx.h - 10);
  ctx.fillText(`r = ${rMax.toFixed(1)}`, ctx.w - 60, ctx.h - 10);
  ctx.fillText('x', 10, 20);

  const feigX = (3.5699 - rMin) / (rMax - rMin) * w;
  if (feigX > 0 && feigX < w) {
    ctx.strokeStyle = 'rgba(255,215,0,0.3)';
    ctx.setLineDash([4,4]);
    ctx.beginPath();
    ctx.moveTo(feigX, 0);
    ctx.lineTo(feigX, h);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,215,0,0.6)';
    ctx.fillText('Î´ â‰ˆ 3.5699', feigX + 4, 20);
  }
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  L-System Trees
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawLSystem() {
  clear();
  applyViewTransform();
  const type = params.lsys_type || 'plant';
  const iter = Math.min(params.lsys_iter || 5, 7);
  const angle = (params.lsys_angle || 25) * Math.PI / 180;
  const step = params.lsys_step || 4;

  const systems = {
    tree: { axiom:'0', rules:{'1':'11','0':'1[0]0'}, drawChars:'01' },
    plant: { axiom:'X', rules:{'X':'F+[[X]-X]-F[-FX]+X','F':'FF'}, drawChars:'FAB' },
    koch: { axiom:'F', rules:{'F':'F+F-F-F+F'}, drawChars:'F' },
    dragon: { axiom:'FX', rules:{'X':'X+YF+','Y':'-FX-Y'}, drawChars:'F' },
    sierpinski: { axiom:'A', rules:{'A':'B-A-B','B':'A+B+A'}, drawChars:'AB' },
  };
  const sys = systems[type] || systems.plant;
  let str = sys.axiom;
  for (let i = 0; i < iter; i++) {
    let next = '';
    for (const ch of str) next += sys.rules[ch] || ch;
    str = next;
  }
  const segs = [];
  let x=0,y=0,a=-Math.PI/2,depth=0;
  const stack = [];
  for (const ch of str) {
    if (sys.drawChars.includes(ch)) {
      const nx=x+step*Math.cos(a), ny=y+step*Math.sin(a);
      segs.push({x1:x,y1:y,x2:nx,y2:ny,depth});
      x=nx;y=ny;
    } else if (ch==='+') a+=angle;
    else if (ch==='-') a-=angle;
    else if (ch==='[') { stack.push({x,y,a,depth}); depth++; }
    else if (ch===']'&&stack.length) { const s=stack.pop(); x=s.x;y=s.y;a=s.a;depth=s.depth; }
  }
  if(!segs.length){ restoreViewTransform(); return; }
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(const s of segs){minX=Math.min(minX,s.x1,s.x2);maxX=Math.max(maxX,s.x1,s.x2);minY=Math.min(minY,s.y1,s.y2);maxY=Math.max(maxY,s.y1,s.y2);}
  const dw=maxX-minX||1, dh=maxY-minY||1;
  const sc=Math.min((ctx.w-60)/dw,(ctx.h-60)/dh);
  const ox=(ctx.w-dw*sc)/2-minX*sc, oy=(ctx.h-dh*sc)/2-minY*sc;
  const md=Math.max(...segs.map(s=>s.depth),1);
  for(const s of segs){
    const t=s.depth/md;
    ctx.beginPath();
    ctx.moveTo(s.x1*sc+ox, s.y1*sc+oy);
    ctx.lineTo(s.x2*sc+ox, s.y2*sc+oy);
    ctx.strokeStyle=`hsl(${90+t*40},60%,${30+t*20}%)`;
    ctx.lineWidth=3-t*2.5;
    ctx.lineCap='round';
    ctx.stroke();
  }
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Turing Patterns (Gray-Scott)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let turingGrid = null;
let turingRunning = false;

function initTuring() {
  const size = params.turing_size || 100;
  const grid = { w:size, h:size, a:new Float32Array(size*size), b:new Float32Array(size*size) };
  for(let i=0;i<size*size;i++){grid.a[i]=1;grid.b[i]=0;}
  let seed=42;
  const rand=()=>{seed=(seed*1103515245+12345)&0x7fffffff;return seed/0x7fffffff;};
  for(let s=0;s<6;s++){
    const cx=Math.floor(rand()*size),cy=Math.floor(rand()*size),sz=3+Math.floor(rand()*8);
    for(let dy=0;dy<sz;dy++)for(let dx=0;dx<sz;dx++){
      const i=((cy+dy)%size)*size+((cx+dx)%size);
      grid.a[i]=0;grid.b[i]=1;
    }
  }
  turingGrid=grid;
}

function stepTuring(steps) {
  const g=turingGrid;
  if(!g)return;
  const presets={spots:{f:0.035,k:0.065},stripes:{f:0.04,k:0.06},coral:{f:0.06,k:0.062},mitosis:{f:0.028,k:0.062},worms:{f:0.058,k:0.065}};
  const p=presets[params.turing_preset||'spots']||presets.spots;
  const da=1.0,db=0.5,w=g.w,h=g.h;
  for(let s=0;s<steps;s++){
    const na=new Float32Array(w*h),nb=new Float32Array(w*h);
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      const i=y*w+x;
      const l=y*w+((x-1+w)%w), r=y*w+((x+1)%w), u=((y-1+h)%h)*w+x, d=((y+1)%h)*w+x;
      const la=g.a[l]+g.a[r]+g.a[u]+g.a[d]-4*g.a[i];
      const lb=g.b[l]+g.b[r]+g.b[u]+g.b[d]-4*g.b[i];
      const ab2=g.a[i]*g.b[i]*g.b[i];
      na[i]=Math.min(1,Math.max(0,g.a[i]+da*la-ab2+p.f*(1-g.a[i])));
      nb[i]=Math.min(1,Math.max(0,g.b[i]+db*lb+ab2-(p.k+p.f)*g.b[i]));
    }
    g.a=na;g.b=nb;
  }
}

function drawTuring() {
  if(!turingGrid)initTuring();
  stepTuring(params.turing_batch||20);
  const g=turingGrid;
  // Turing uses putImageData, handle zoom via CSS-like approach
  // We'll draw to an offscreen buffer then draw it with transform
  const scale=Math.min(Math.floor(ctx.w/g.w),Math.floor(ctx.h/g.h));
  const imgW = g.w*scale, imgH = g.h*scale;
  const ox=(ctx.w-imgW)/2, oy=(ctx.h-imgH)/2;
  const imgData=ctx.createImageData(imgW,imgH);
  for(let y=0;y<g.h;y++)for(let x=0;x<g.w;x++){
    const v=g.b[y*g.w+x];
    const r=Math.floor(v*255),gr=Math.floor(v*0.6*255),b=Math.min(255,50+Math.floor(v*128));
    for(let sy=0;sy<scale;sy++)for(let sx=0;sx<scale;sx++){
      const idx=((y*scale+sy)*imgW+(x*scale+sx))*4;
      imgData.data[idx]=r;imgData.data[idx+1]=gr;imgData.data[idx+2]=b;imgData.data[idx+3]=255;
    }
  }
  // Create temp canvas for the image data, then draw with transform
  clear();
  if (!drawTuring._tmpCanvas) {
    drawTuring._tmpCanvas = document.createElement('canvas');
  }
  const tmp = drawTuring._tmpCanvas;
  tmp.width = imgW;
  tmp.height = imgH;
  tmp.getContext('2d').putImageData(imgData, 0, 0);
  applyViewTransform();
  ctx.drawImage(tmp, ox, oy);
  restoreViewTransform();
}

let turingAnimId=null;
function animateTuring(){
  drawTuring();
  if(turingRunning) turingAnimId=requestAnimationFrame(animateTuring);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Tessellations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawTessellation() {
  clear();
  applyViewTransform();
  const type = params.tess_type || 'hexagon';
  const size = params.tess_size || 30;
  const cx = ctx.w, cy = ctx.h;

  if (type === 'hexagon') {
    const h = size * Math.sqrt(3);
    const cols = Math.ceil(cx / (size * 1.5)) + 2;
    const rows = Math.ceil(cy / h) + 2;
    for (let r = -1; r < rows; r++) {
      for (let c = -1; c < cols; c++) {
        const x = c * size * 1.5;
        const y = r * h + (c % 2 ? h/2 : 0);
        const hue = ((x+y)*0.3) % 360;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const a = Math.PI/6 + i * Math.PI/3;
          const px = x + size * Math.cos(a);
          const py = y + size * Math.sin(a);
          if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = `hsl(${hue},50%,25%)`;
        ctx.fill();
        ctx.strokeStyle = `hsl(${hue},60%,45%)`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }
  } else if (type === 'voronoi') {
    let seed = 42;
    const rand = () => { seed=(seed*1103515245+12345)&0x7fffffff; return seed/0x7fffffff; };
    const nPts = params.tess_points || 40;
    const sites = [];
    for (let i = 0; i < nPts; i++) sites.push({x:rand()*cx, y:rand()*cy, hue:rand()*360});
    const step = 4;
    for (let y = 0; y < cy; y += step) {
      for (let x = 0; x < cx; x += step) {
        let minD = Infinity, closest = sites[0];
        for (const s of sites) {
          const d = (x-s.x)**2 + (y-s.y)**2;
          if (d < minD) { minD = d; closest = s; }
        }
        ctx.fillStyle = `hsl(${closest.hue},40%,${25+Math.sqrt(minD)*0.05}%)`;
        ctx.fillRect(x, y, step, step);
      }
    }
    for (const s of sites) {
      ctx.beginPath();
      ctx.arc(s.x, s.y, 3, 0, Math.PI*2);
      ctx.fillStyle = 'white';
      ctx.fill();
    }
  }
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Fibonacci Spiral (Golden Rectangles)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawFibonacci() {
  clear();
  applyViewTransform();
  const n = params.fib_count || 10;
  const fibs = [1,1];
  for(let i=2;i<n;i++) fibs.push(fibs[i-1]+fibs[i-2]);
  const cx=ctx.w/2, cy=ctx.h/2;
  const maxFib = fibs[fibs.length-1];
  const scale = Math.min(ctx.w,ctx.h)*0.4/maxFib;
  let x=cx,y=cy,dir=0;
  const colors = ['#ff6b6b','#ffd93d','#6bcb77','#4d96ff','#9b59b6','#e74c3c','#f39c12','#2ecc71','#3498db','#8e44ad','#e67e22','#1abc9c'];

  for(let i=0;i<fibs.length;i++){
    const s=fibs[i]*scale;
    ctx.strokeStyle=colors[i%colors.length];
    ctx.lineWidth=2;
    ctx.globalAlpha=0.4;
    let rx,ry;
    if(dir===0){rx=x;ry=y-s;}
    else if(dir===1){rx=x;ry=y;}
    else if(dir===2){rx=x-s;ry=y;}
    else{rx=x-s;ry=y-s;}
    ctx.strokeRect(rx,ry,s,s);
    ctx.globalAlpha=0.9;
    ctx.beginPath();
    let startAngle,arcCX,arcCY;
    if(dir===0){arcCX=rx;arcCY=ry+s;startAngle=-Math.PI/2;}
    else if(dir===1){arcCX=rx;arcCY=ry;startAngle=0;}
    else if(dir===2){arcCX=rx+s;arcCY=ry;startAngle=Math.PI/2;}
    else{arcCX=rx+s;arcCY=ry+s;startAngle=Math.PI;}
    ctx.arc(arcCX,arcCY,s,startAngle,startAngle+Math.PI/2);
    ctx.strokeStyle=colors[i%colors.length];
    ctx.lineWidth=2.5;
    ctx.stroke();
    if(dir===0){x=rx+s;y=ry;}
    else if(dir===1){x=rx+s;y=ry+s;}
    else if(dir===2){x=rx;y=ry+s;}
    else{x=rx;y=ry;}
    dir=(dir+1)%4;
  }
  ctx.globalAlpha=1;
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.font='12px monospace';
  ctx.fillText(`Fibonacci: ${fibs.join(', ')}`,10,ctx.h-10);
  restoreViewTransform();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Symmetry
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawSymmetry() {
  clear();
  applyViewTransform();
  const type = params.sym_type || 'radial';
  const folds = params.sym_folds || 6;
  const cx = ctx.w/2, cy = ctx.h/2;
  const maxR = Math.min(cx,cy)*0.8;

  if (type === 'radial') {
    for (let f = 0; f < folds; f++) {
      const baseAngle = (f / folds) * Math.PI * 2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(baseAngle);
      drawSymArm(maxR, folds);
      ctx.scale(1, -1);
      drawSymArm(maxR, folds);
      ctx.restore();
    }
  } else if (type === 'bilateral') {
    const wing = (side) => {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(side, 1);
      for (let i = 0; i < 5; i++) {
        const r = maxR * (0.3 + i * 0.15);
        const hue = i * 60;
        ctx.beginPath();
        ctx.ellipse(r*0.4, -r*0.2, r*0.5, r*0.3, -0.3, 0, Math.PI*2);
        ctx.fillStyle = `hsla(${hue},70%,50%,0.3)`;
        ctx.fill();
        ctx.strokeStyle = `hsl(${hue},70%,60%)`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.moveTo(0, -maxR*0.6);
      ctx.lineTo(0, maxR*0.6);
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
    };
    wing(1);
    wing(-1);
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.moveTo(cx, cy-maxR);
    ctx.lineTo(cx, cy+maxR);
    ctx.strokeStyle = 'rgba(255,215,0,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
  }
  restoreViewTransform();
}

function drawSymArm(maxR, folds) {
  const branches = 4;
  for (let b = 0; b < branches; b++) {
    const r = maxR * (b + 1) / branches;
    const size = maxR / branches * 0.4;
    const hue = b * 90 + 180;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(r, 0);
    ctx.strokeStyle = `hsl(${hue},60%,60%)`;
    ctx.lineWidth = 2 - b * 0.3;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(r, 0);
    ctx.lineTo(r + size * 0.7, -size * 0.4);
    ctx.moveTo(r, 0);
    ctx.lineTo(r + size * 0.7, size * 0.4);
    ctx.strokeStyle = `hsl(${hue},50%,70%)`;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(r, 0, 3, 0, Math.PI*2);
    ctx.fillStyle = `hsl(${hue},60%,70%)`;
    ctx.fill();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Drawing dispatcher
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function draw() {
  if (animId) { cancelAnimationFrame(animId); animId = null; }
  if (turingAnimId) { cancelAnimationFrame(turingAnimId); turingAnimId = null; turingRunning = false; }
  const drawFns = {
    phyllotaxis: drawPhyllotaxis,
    fractals_fern: drawFern,
    fractals_koch: drawKoch,
    fractals_mandelbrot: drawMandelbrot,
    spirals: drawSpirals,
    chaos_lorenz: drawLorenz,
    chaos_logistic: drawLogistic,
    lsystem: drawLSystem,
    turing: () => { turingGrid=null; initTuring(); turingRunning=true; animateTuring(); },
    tessellation: drawTessellation,
    fibonacci: drawFibonacci,
    symmetry: drawSymmetry,
  };
  const fn = drawFns[currentCat];
  if (fn) fn();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Knowledge Links Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const knowledgeLinks = {
  phyllotaxis: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Phyllotaxis', desc:'Comprehensive overview of phyllotactic patterns in plants', url:'https://en.wikipedia.org/wiki/Phyllotaxis' },
    { type:'paper', icon:'ğŸ“„', title:'Douady & Couder (1992)', desc:'Phyllotaxis as a Physical Self-Organized Growth Process â€” the landmark paper on spiral phyllotaxis', url:'https://doi.org/10.1103/PhysRevLett.68.2098' },
    { type:'video', icon:'ğŸ¥', title:'Vi Hart: Fibonacci Spirals', desc:'Doodling in Math â€” an entertaining YouTube series on spirals in nature', url:'https://www.youtube.com/watch?v=ahXIMUkSXX0' },
    { type:'web', icon:'ğŸ”—', title:'Khan Academy: Fibonacci Sequence', desc:'Interactive lessons on the Fibonacci sequence and its properties', url:'https://www.khanacademy.org/math/math-for-fun-and-glory/vi-hart/spirals-702702/v/doodling-in-math-spirals-fibonacci-and-being-a-plant-1-of-3' },
  ],
  fractals_fern: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Fractal', desc:'Overview of fractals, self-similarity, and fractal dimension', url:'https://en.wikipedia.org/wiki/Fractal' },
    { type:'book', icon:'ğŸ“–', title:'The Fractal Geometry of Nature', desc:'BenoÃ®t Mandelbrot\'s seminal 1982 book that introduced fractals to the world', url:'https://en.wikipedia.org/wiki/The_Fractal_Geometry_of_Nature' },
    { type:'video', icon:'ğŸ¥', title:'3Blue1Brown: Fractals', desc:'Beautiful visual explanations of fractal geometry and self-similarity', url:'https://www.youtube.com/watch?v=gB9n2gHsHN4' },
    { type:'web', icon:'ğŸ”—', title:'Fractal Foundation', desc:'Educational resources about fractals with interactive explorations', url:'https://fractalfoundation.org' },
  ],
  fractals_koch: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Fractal', desc:'Overview of fractals, self-similarity, and fractal dimension', url:'https://en.wikipedia.org/wiki/Fractal' },
    { type:'book', icon:'ğŸ“–', title:'The Fractal Geometry of Nature', desc:'BenoÃ®t Mandelbrot\'s seminal 1982 book that introduced fractals to the world', url:'https://en.wikipedia.org/wiki/The_Fractal_Geometry_of_Nature' },
    { type:'video', icon:'ğŸ¥', title:'3Blue1Brown: Fractals', desc:'Beautiful visual explanations of fractal geometry and self-similarity', url:'https://www.youtube.com/watch?v=gB9n2gHsHN4' },
    { type:'web', icon:'ğŸ”—', title:'Fractal Foundation', desc:'Educational resources about fractals with interactive explorations', url:'https://fractalfoundation.org' },
  ],
  fractals_mandelbrot: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Fractal', desc:'Overview of fractals, self-similarity, and fractal dimension', url:'https://en.wikipedia.org/wiki/Fractal' },
    { type:'book', icon:'ğŸ“–', title:'The Fractal Geometry of Nature', desc:'BenoÃ®t Mandelbrot\'s seminal 1982 book that introduced fractals to the world', url:'https://en.wikipedia.org/wiki/The_Fractal_Geometry_of_Nature' },
    { type:'video', icon:'ğŸ¥', title:'3Blue1Brown: Fractals', desc:'Beautiful visual explanations of fractal geometry and self-similarity', url:'https://www.youtube.com/watch?v=gB9n2gHsHN4' },
    { type:'web', icon:'ğŸ”—', title:'Fractal Foundation', desc:'Educational resources about fractals with interactive explorations', url:'https://fractalfoundation.org' },
  ],
  spirals: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Logarithmic Spiral', desc:'The mathematics behind the most common spiral in nature', url:'https://en.wikipedia.org/wiki/Logarithmic_spiral' },
    { type:'web', icon:'ğŸ”—', title:'Wolfram MathWorld: Spirals', desc:'Comprehensive mathematical reference for all types of spiral curves', url:'https://mathworld.wolfram.com/Spiral.html' },
    { type:'web', icon:'ğŸ”—', title:'Nature\'s Spirals', desc:'How logarithmic spirals appear in nautilus shells, galaxies, and hurricanes', url:'https://en.wikipedia.org/wiki/Spiral#In_nature' },
  ],
  chaos_lorenz: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Chaos Theory', desc:'Introduction to chaos theory, strange attractors, and sensitive dependence', url:'https://en.wikipedia.org/wiki/Chaos_theory' },
    { type:'paper', icon:'ğŸ“„', title:'Lorenz (1963)', desc:'"Deterministic Nonperiodic Flow" â€” the paper that launched chaos theory', url:'https://doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2' },
    { type:'video', icon:'ğŸ¥', title:'Veritasium: Chaos Theory', desc:'This equation will change how you see the world â€” a popular science exploration', url:'https://www.youtube.com/watch?v=ovJcsL7vyrk' },
    { type:'book', icon:'ğŸ“–', title:'Nonlinear Dynamics and Chaos', desc:'Steven Strogatz\'s classic textbook â€” the gold standard for learning chaos theory', url:'https://www.stevenstrogatz.com/books/nonlinear-dynamics-and-chaos-with-applications-to-physics-biology-chemistry-and-engineering' },
  ],
  chaos_logistic: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Chaos Theory', desc:'Introduction to chaos theory, strange attractors, and sensitive dependence', url:'https://en.wikipedia.org/wiki/Chaos_theory' },
    { type:'paper', icon:'ğŸ“„', title:'Lorenz (1963)', desc:'"Deterministic Nonperiodic Flow" â€” the paper that launched chaos theory', url:'https://doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2' },
    { type:'video', icon:'ğŸ¥', title:'Veritasium: Chaos Theory', desc:'This equation will change how you see the world â€” a popular science exploration', url:'https://www.youtube.com/watch?v=ovJcsL7vyrk' },
    { type:'book', icon:'ğŸ“–', title:'Nonlinear Dynamics and Chaos', desc:'Steven Strogatz\'s classic textbook â€” the gold standard for learning chaos theory', url:'https://www.stevenstrogatz.com/books/nonlinear-dynamics-and-chaos-with-applications-to-physics-biology-chemistry-and-engineering' },
  ],
  lsystem: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: L-System', desc:'Formal grammar systems invented by Aristid Lindenmayer for modeling plant growth', url:'https://en.wikipedia.org/wiki/L-system' },
    { type:'book', icon:'ğŸ“–', title:'The Algorithmic Beauty of Plants', desc:'Lindenmayer & Prusinkiewicz â€” the definitive reference, available as a free PDF', url:'http://algorithmicbotany.org/papers/#abop' },
    { type:'web', icon:'ğŸ”—', title:'Paul Bourke: L-System', desc:'Detailed examples and implementations of various L-system types', url:'https://paulbourke.net/fractals/lsys/' },
  ],
  turing: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Turing Pattern', desc:'How reaction-diffusion systems create biological patterns', url:'https://en.wikipedia.org/wiki/Turing_pattern' },
    { type:'paper', icon:'ğŸ“„', title:'Turing (1952)', desc:'"The Chemical Basis of Morphogenesis" â€” Alan Turing\'s groundbreaking paper on pattern formation', url:'https://doi.org/10.1098/rstb.1952.0012' },
    { type:'book', icon:'ğŸ“–', title:'Patterns in Nature', desc:'Philip Ball\'s beautifully illustrated exploration of natural pattern formation', url:'https://en.wikipedia.org/wiki/Patterns_in_Nature' },
    { type:'paper', icon:'ğŸ“„', title:'Pearson (1993)', desc:'Complex patterns in a simple system â€” the Gray-Scott model parameter space exploration', url:'https://doi.org/10.1126/science.261.5118.189' },
  ],
  tessellation: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Tessellation', desc:'How shapes tile the plane â€” from regular polygons to Penrose tiles', url:'https://en.wikipedia.org/wiki/Tessellation' },
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Voronoi Diagram', desc:'Partitioning space by nearest-neighbor distance', url:'https://en.wikipedia.org/wiki/Voronoi_diagram' },
  ],
  fibonacci: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Fibonacci Sequence', desc:'The famous sequence and its deep connections to the golden ratio', url:'https://en.wikipedia.org/wiki/Fibonacci_sequence' },
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Golden Ratio', desc:'Ï† = 1.618... â€” the most irrational number and its role in nature and art', url:'https://en.wikipedia.org/wiki/Golden_ratio' },
    { type:'video', icon:'ğŸ¥', title:'Numberphile: Fibonacci', desc:'Engaging explorations of Fibonacci numbers and where they appear', url:'https://www.youtube.com/watch?v=Nu-lW-Ifyec' },
  ],
  symmetry: [
    { type:'web', icon:'ğŸ”—', title:'Wikipedia: Symmetry in Biology', desc:'How and why symmetry evolved in living organisms', url:'https://en.wikipedia.org/wiki/Symmetry_in_biology' },
    { type:'book', icon:'ğŸ“–', title:'The Symmetries of Things', desc:'Conway, Burgiel & Goodman-Strauss â€” a visually stunning mathematics of symmetry', url:'https://en.wikipedia.org/wiki/The_Symmetries_of_Things' },
  ],
};

function renderKnowledgeLinks(id) {
  const panel = document.getElementById('knowledge');
  const links = knowledgeLinks[id];
  if (!links || !links.length) { panel.style.display = 'none'; return; }
  panel.style.display = 'block';

  // Group by type
  const groups = {};
  const typeOrder = ['web','paper','book','video'];
  const typeLabels = { web:'ğŸ”— Web Resources', paper:'ğŸ“„ Papers & Articles', book:'ğŸ“– Books', video:'ğŸ¥ Videos' };
  for (const link of links) {
    if (!groups[link.type]) groups[link.type] = [];
    groups[link.type].push(link);
  }

  let html = '<h3>ğŸ“š Learn More</h3>';
  for (const type of typeOrder) {
    if (!groups[type]) continue;
    html += `<div class="knowledge-group"><div class="knowledge-group-title">${typeLabels[type] || type}</div>`;
    for (const link of groups[type]) {
      html += `<a class="knowledge-link" href="${link.url}" target="_blank" rel="noopener noreferrer">
  <span class="kl-icon">${link.icon}</span>
  <div class="kl-info">
    <div class="kl-title">${link.title}</div>
    <div class="kl-desc">${link.desc}</div>
  </div>
  <span class="kl-arrow">â†’</span>
</a>`;
    }
    html += '</div>';
  }
  panel.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Category configs (controls + info)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const catConfigs = {
  phyllotaxis: {
    controls: [
      {id:'count',label:'Number of Seeds',type:'range',min:10,max:2000,step:10,default:500},
      {id:'angle',label:'Divergence Angle (Â°)',type:'range',min:0,max:360,step:0.001,default:137.508},
      {id:'scale',label:'Spacing Scale',type:'range',min:1,max:15,step:0.1,default:4},
      {id:'colorScheme',label:'Color Scheme',type:'select',options:['spiral','radius','fibonacci','golden']},
    ],
    info: {
      title:'ğŸŒ» The Mathematics of Plant Growth',
      html:`<p>Plants arrange leaves, seeds, and petals using the <strong>golden angle</strong> â€” approximately <span class="math">137.508Â°</span>. This is the angle that divides a circle in the golden ratio.</p>
<div class="formula-block">Î¸â‚™ = n Ã— 137.508Â°<br>râ‚™ = c Ã— âˆšn<br><br>Golden angle = 360Â° Ã— (2 - Ï†) = 360Â° / Ï†Â²<br>where Ï† = (1 + âˆš5) / 2 â‰ˆ 1.618</div>
<p>This angle is special because it's the <em>most irrational</em> number â€” it avoids creating gaps or overlapping lines, giving optimal packing. Try changing the angle: even <span class="math">137.5Â°</span> vs <span class="math">137.508Â°</span> looks different!</p>
<p><strong>Parastichy spirals:</strong> Count the visible spirals â€” they're always consecutive Fibonacci numbers (21/34, 55/89).</p>
<div class="nature-examples"><span class="nature-tag">ğŸŒ» Sunflower heads</span><span class="nature-tag">ğŸŒ¹ Rose petals</span><span class="nature-tag">ğŸ Pineapple scales</span><span class="nature-tag">ğŸŒ² Pine cones</span><span class="nature-tag">ğŸ¥¬ Romanesco</span></div>`
    }
  },
  fractals_fern: {
    controls: [
      {id:'iterations',label:'Points',type:'range',min:1000,max:100000,step:1000,default:50000},
      {id:'fern_a2',label:'Left Leaflet (a)',type:'range',min:-0.5,max:0.5,step:0.01,default:0.2},
      {id:'fern_b2',label:'Left Leaflet (b)',type:'range',min:-0.5,max:0.5,step:0.01,default:-0.26},
      {id:'fern_a3',label:'Right Leaflet (a)',type:'range',min:-0.5,max:0.5,step:0.01,default:-0.15},
      {id:'fern_b3',label:'Right Leaflet (b)',type:'range',min:-0.5,max:0.5,step:0.01,default:0.28},
    ],
    info: {
      title:'ğŸŒ¿ The Barnsley Fern',
      html:`<p>Michael Barnsley discovered that a realistic fern can be generated from just <strong>four affine transformations</strong>, each chosen randomly with different probabilities.</p>
<div class="formula-block">fâ‚: (x,y) â†’ (0, 0.16y)           p=1%  [stem]<br>fâ‚‚: (x,y) â†’ (0.85x+0.04y, -0.04x+0.85y+1.6)  p=85% [main]<br>fâ‚ƒ: (x,y) â†’ (0.2x-0.26y, 0.23x+0.22y+1.6)   p=7%  [left]<br>fâ‚„: (x,y) â†’ (-0.15x+0.28y, 0.26x+0.24y+0.44) p=7%  [right]</div>
<p>This is an <strong>Iterated Function System (IFS)</strong> â€” the same principle behind image compression. Fractal dimension â‰ˆ 1.45.</p>
<p>Try adjusting the leaflet parameters to create different fern species!</p>
<div class="nature-examples"><span class="nature-tag">ğŸŒ¿ Fern fronds</span><span class="nature-tag">ğŸ¥¦ Romanesco</span><span class="nature-tag">âš¡ Lightning</span><span class="nature-tag">ğŸ« Lung bronchi</span></div>`
    }
  },
  fractals_koch: {
    controls: [
      {id:'koch_iter',label:'Iterations',type:'range',min:0,max:7,step:1,default:4},
    ],
    info: {
      title:'â„ï¸ Koch Snowflake â€” Infinite Perimeter, Finite Area',
      html:`<p>Start with a triangle. Replace each line segment's middle third with an equilateral bump. Repeat forever.</p>
<div class="formula-block">Perimeter = 3s Ã— (4/3)â¿ â†’ âˆ<br>Area = (2sÂ²âˆš3/5) Ã— (1 - (4/9)â¿ Ã— ...) â†’ finite<br>Fractal dimension = ln(4)/ln(3) â‰ˆ 1.2619</div>
<p>A curve with <strong>infinite length</strong> enclosing a <strong>finite area</strong>. The perimeter grows by 4/3 each iteration while the area converges.</p>
<div class="nature-examples"><span class="nature-tag">â„ï¸ Snowflakes</span><span class="nature-tag">ğŸ”ï¸ Coastlines</span><span class="nature-tag">ğŸ«§ Crystal growth</span></div>`
    }
  },
  fractals_mandelbrot: {
    controls: [
      {id:'mandel_iter',label:'Max Iterations',type:'range',min:20,max:500,step:10,default:80},
      {id:'mandel_zoom',label:'Zoom',type:'range',min:0.5,max:100,step:0.5,default:1},
      {id:'mandel_cx',label:'Center X',type:'range',min:-2.5,max:1,step:0.01,default:-0.5},
      {id:'mandel_cy',label:'Center Y',type:'range',min:-1.5,max:1.5,step:0.01,default:0},
    ],
    info: {
      title:'ğŸ”® The Mandelbrot Set',
      html:`<p>The most famous fractal: iterate <span class="math">z â†’ zÂ² + c</span> and color based on how fast it escapes.</p>
<div class="formula-block">zâ‚€ = 0<br>zâ‚™â‚Šâ‚ = zâ‚™Â² + c<br><br>Point c is IN the set if |zâ‚™| stays bounded.<br>Color = escape iteration count.</div>
<p>The boundary has <strong>infinite complexity at every scale</strong>. Zoom into the edges to find miniature copies of the whole set â€” self-similarity across scales.</p>
<p>Try zooming to: Center X = <span class="math">-0.745</span>, Y = <span class="math">0.186</span>, Zoom = <span class="math">50</span></p>
<div class="nature-examples"><span class="nature-tag">ğŸ”¬ Infinite detail</span><span class="nature-tag">ğŸŒŠ Julia sets</span><span class="nature-tag">ğŸ“ Complex dynamics</span></div>`
    }
  },
  spirals: {
    controls: [
      {id:'spiral_type',label:'Spiral Type',type:'select',options:['golden','logarithmic','archimedean','fermat']},
      {id:'spiral_turns',label:'Turns',type:'range',min:1,max:20,step:0.5,default:6},
      {id:'spiral_pts',label:'Resolution',type:'range',min:100,max:5000,step:100,default:2000},
    ],
    info: {
      title:'ğŸš The Language of Spirals',
      html:`<p>Spirals appear when growth combines with rotation. Different growth laws produce different spirals:</p>
<div class="formula-block"><strong>Logarithmic:</strong> r = a Ã— e^(bÎ¸)    [nautilus, galaxies]<br><strong>Archimedean:</strong> r = a + bÎ¸         [watch springs, ropes]<br><strong>Fermat:</strong>      r = a Ã— âˆšÎ¸         [sunflower background]<br><strong>Golden:</strong>      r = a Ã— Ï†^(2Î¸/Ï€)   [special log spiral]</div>
<p>The <strong>golden spiral</strong> is a logarithmic spiral that grows by Ï† every quarter turn. It approximates the spiral in nautilus shells, galaxy arms, and hurricane formations.</p>
<div class="nature-examples"><span class="nature-tag">ğŸš Nautilus shell</span><span class="nature-tag">ğŸŒ€ Galaxy arms</span><span class="nature-tag">ğŸŒªï¸ Hurricanes</span><span class="nature-tag">ğŸ§¬ DNA helix</span><span class="nature-tag">ğŸ Ram horns</span></div>`
    }
  },
  chaos_lorenz: {
    controls: [
      {id:'lorenz_sigma',label:'Ïƒ (Prandtl)',type:'range',min:1,max:30,step:0.5,default:10},
      {id:'lorenz_rho',label:'Ï (Rayleigh)',type:'range',min:0.1,max:50,step:0.5,default:28},
      {id:'lorenz_beta',label:'Î²',type:'range',min:0.1,max:8,step:0.1,default:2.667},
      {id:'lorenz_steps',label:'Time Steps',type:'range',min:5000,max:50000,step:1000,default:20000},
    ],
    info: {
      title:'ğŸ¦‹ The Lorenz Attractor',
      html:`<p>In 1963, meteorologist Edward Lorenz discovered that a simplified weather model produces beautiful, never-repeating trajectories shaped like a butterfly.</p>
<div class="formula-block">dx/dt = Ïƒ(y - x)<br>dy/dt = x(Ï - z) - y<br>dz/dt = xy - Î²z<br><br>Classic parameters: Ïƒ=10, Ï=28, Î²=8/3</div>
<p>The <strong>butterfly effect</strong>: two starting points differing by 10â»Â¹â° diverge completely within seconds. Deterministic but unpredictable â€” this is <strong>chaos</strong>.</p>
<p>The trajectory never crosses itself and never repeats, yet stays confined to a strange attractor with fractal dimension â‰ˆ 2.06.</p>
<div class="nature-examples"><span class="nature-tag">ğŸŒ¤ï¸ Weather</span><span class="nature-tag">ğŸ’“ Heart rhythms</span><span class="nature-tag">ğŸŒŠ Turbulence</span><span class="nature-tag">ğŸª Orbital mechanics</span></div>`
    }
  },
  chaos_logistic: {
    controls: [
      {id:'logistic_rmin',label:'r min',type:'range',min:0,max:3.5,step:0.1,default:2.5},
      {id:'logistic_rmax',label:'r max',type:'range',min:3,max:4,step:0.01,default:4.0},
    ],
    info: {
      title:'ğŸ“ˆ The Logistic Map â€” Order to Chaos',
      html:`<p>The simplest equation that produces chaos:</p>
<div class="formula-block">xâ‚™â‚Šâ‚ = r Ã— xâ‚™ Ã— (1 - xâ‚™)<br><br>r < 3.0:  stable fixed point<br>r â‰ˆ 3.0:  period-2 oscillation<br>r â‰ˆ 3.45: period-4 oscillation<br>r â‰ˆ 3.57: onset of chaos (Feigenbaum point)<br>r = 4.0:  full chaos</div>
<p>The <strong>Feigenbaum constant</strong> Î´ â‰ˆ 4.6692 describes the rate of period-doubling â€” and it's <em>universal</em>, appearing in all period-doubling cascades in nature.</p>
<div class="nature-examples"><span class="nature-tag">ğŸ° Population dynamics</span><span class="nature-tag">ğŸ’§ Dripping faucet</span><span class="nature-tag">ğŸ“¡ Signal processing</span></div>`
    }
  },
  lsystem: {
    controls: [
      {id:'lsys_type',label:'System',type:'select',options:['plant','tree','koch','dragon','sierpinski']},
      {id:'lsys_iter',label:'Iterations',type:'range',min:1,max:7,step:1,default:5},
      {id:'lsys_angle',label:'Branch Angle (Â°)',type:'range',min:5,max:90,step:1,default:25},
      {id:'lsys_step',label:'Step Length',type:'range',min:1,max:15,step:0.5,default:4},
    ],
    info: {
      title:'ğŸŒ³ L-Systems â€” Growing Trees from Grammars',
      html:`<p>Aristid Lindenmayer invented L-systems in 1968 to model plant growth. A simple string-rewriting grammar + turtle graphics produces stunning botanical structures.</p>
<div class="formula-block"><strong>Plant:</strong><br>Axiom: X<br>X â†’ F+[[X]-X]-F[-FX]+X<br>F â†’ FF<br><br>F=draw  +=turn left  -=turn right<br>[=save position  ]=restore position</div>
<p>The same principle generates trees, ferns, corals, blood vessels, rivers, and lightning. Nature reuses branching patterns because they're optimal for distribution networks.</p>
<div class="nature-examples"><span class="nature-tag">ğŸŒ³ Trees</span><span class="nature-tag">ğŸ« Lungs</span><span class="nature-tag">ğŸ©¸ Blood vessels</span><span class="nature-tag">âš¡ Lightning</span><span class="nature-tag">ğŸï¸ River deltas</span></div>`
    }
  },
  turing: {
    controls: [
      {id:'turing_preset',label:'Pattern',type:'select',options:['spots','stripes','coral','mitosis','worms']},
      {id:'turing_size',label:'Grid Size',type:'range',min:50,max:200,step:10,default:100},
      {id:'turing_batch',label:'Steps per Frame',type:'range',min:5,max:100,step:5,default:20},
    ],
    info: {
      title:'ğŸ† Turing Patterns â€” How Leopards Get Spots',
      html:`<p>In 1952, Alan Turing showed that two interacting chemicals (morphogens) diffusing at different rates can spontaneously create stable patterns.</p>
<div class="formula-block"><strong>Gray-Scott Model:</strong><br>âˆ‚A/âˆ‚t = Dâ‚âˆ‡Â²A - ABÂ² + f(1-A)<br>âˆ‚B/âˆ‚t = D_bâˆ‡Â²B + ABÂ² - (k+f)B<br><br>f = feed rate (replenish A)<br>k = kill rate (remove B)<br>Different f,k â†’ different patterns!</div>
<p>By tuning just two parameters (feed and kill rate), the same equation produces spots, stripes, labyrinthine patterns, and traveling waves.</p>
<div class="nature-examples"><span class="nature-tag">ğŸ† Leopard spots</span><span class="nature-tag">ğŸ¦“ Zebra stripes</span><span class="nature-tag">ğŸš Seashell pigments</span><span class="nature-tag">ğŸ§  Brain coral</span><span class="nature-tag">ğŸ¡ Angelfish</span></div>`
    }
  },
  tessellation: {
    controls: [
      {id:'tess_type',label:'Type',type:'select',options:['hexagon','voronoi']},
      {id:'tess_size',label:'Cell Size',type:'range',min:10,max:80,step:2,default:30},
      {id:'tess_points',label:'Voronoi Points',type:'range',min:10,max:100,step:5,default:40},
    ],
    info: {
      title:'ğŸ¯ Tessellations â€” Why Bees Chose Hexagons',
      html:`<p>Hexagons tile the plane with the <strong>minimum perimeter per unit area</strong> â€” the Honeycomb Conjecture, proven in 1999 by Thomas Hales.</p>
<div class="formula-block">Regular polygon tilings: triangle, square, hexagon<br><br>Perimeter per unit area:<br>  Triangle: 2Ã—3^(1/4) â‰ˆ 2.632<br>  Square:   4/1 = 4.000<br>  Hexagon:  2Ã—(4/3)^(1/4) â‰ˆ 2.149  â† winner!</div>
<p><strong>Voronoi diagrams</strong> partition space by nearest-neighbor distance, naturally arising in giraffe skin patterns, dragonfly wings, and cracked mud.</p>
<div class="nature-examples"><span class="nature-tag">ğŸ¯ Honeycombs</span><span class="nature-tag">ğŸ¦’ Giraffe skin</span><span class="nature-tag">ğŸ¢ Turtle shells</span><span class="nature-tag">ğŸ«§ Soap bubbles</span><span class="nature-tag">ğŸŒ Basalt columns</span></div>`
    }
  },
  fibonacci: {
    controls: [
      {id:'fib_count',label:'Fibonacci Terms',type:'range',min:3,max:14,step:1,default:10},
    ],
    info: {
      title:'ğŸ”¢ The Fibonacci Spiral',
      html:`<p>Build squares with Fibonacci side lengths (1,1,2,3,5,8,13,...) and connect quarter-circle arcs â€” you get the <strong>golden spiral</strong>.</p>
<div class="formula-block">F(n) = F(n-1) + F(n-2)<br>F(n)/F(n-1) â†’ Ï† â‰ˆ 1.618033...<br><br>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...<br><br>Flower petals often come in Fibonacci numbers:<br>  Lily=3, Buttercup=5, Delphinium=8,<br>  Marigold=13, Daisy=21 or 34</div>
<p>The convergence of F(n)/F(n-1) to Ï† is the <em>slowest possible</em> â€” making Ï† the "most irrational" number, which is exactly why it appears in optimal packing.</p>
<div class="nature-examples"><span class="nature-tag">ğŸŒ¼ Flower petals</span><span class="nature-tag">ğŸš Shell chambers</span><span class="nature-tag">ğŸŒ» Seed spirals</span><span class="nature-tag">ğŸ Pineapple</span></div>`
    }
  },
  symmetry: {
    controls: [
      {id:'sym_type',label:'Symmetry Type',type:'select',options:['radial','bilateral']},
      {id:'sym_folds',label:'Folds (Radial)',type:'range',min:3,max:12,step:1,default:6},
    ],
    info: {
      title:'ğŸ¦‹ Symmetry in Nature',
      html:`<p>Symmetry is everywhere because physical laws don't prefer any direction.</p>
<div class="formula-block"><strong>Bilateral:</strong> one mirror plane (humans, butterflies, leaves)<br><strong>Radial:</strong> multiple rotational axes (starfish=5, snowflakes=6)<br><strong>Rotational:</strong> invariant under rotation (jellyfish)</div>
<p><strong>Bilateral symmetry</strong> evolved because animals move in one direction â€” they need a front and back, but left and right are equivalent. <strong>Radial symmetry</strong> appears in organisms that don't move or float freely.</p>
<p>Snowflakes have 6-fold symmetry because water molecules form hexagonal crystals at 120Â° angles.</p>
<div class="nature-examples"><span class="nature-tag">ğŸ¦‹ Butterflies</span><span class="nature-tag">â­ Starfish (5-fold)</span><span class="nature-tag">â„ï¸ Snowflakes (6-fold)</span><span class="nature-tag">ğŸŒ¸ Flowers</span></div>`
    }
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Load category
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loadCategory(id) {
  currentCat = id;
  buildNav();
  const cat = categories.find(c => c.id === id);
  const cfg = catConfigs[id];
  if (!cat || !cfg) return;

  // Reset zoom/pan when switching categories
  viewZoom = 1.0;
  viewPanX = 0;
  viewPanY = 0;
  updateZoomIndicator();

  document.getElementById('title').textContent = cat.icon + ' ' + cat.label;
  document.getElementById('subtitle').textContent = cat.subtitle;

  // Build controls
  const controlsDiv = document.getElementById('controls');
  let html = '<h3>âš™ï¸ Parameters</h3><div class="control-grid">';
  for (const c of cfg.controls) {
    if (c.type === 'range') {
      const val = params[c.id] !== undefined ? params[c.id] : c.default;
      params[c.id] = val;
      html += `<div class="control-item"><label>${c.label} <span class="value" id="val_${c.id}">${val}</span></label>
<input type="range" min="${c.min}" max="${c.max}" step="${c.step}" value="${val}" oninput="setParam('${c.id}',this.value,${c.default})"></div>`;
    } else if (c.type === 'select') {
      html += `<div class="control-item"><label>${c.label}</label><select onchange="setParam('${c.id}',this.value)">`;
      for (const opt of c.options) {
        const sel = params[c.id] === opt ? 'selected' : '';
        html += `<option value="${opt}" ${sel}>${opt.charAt(0).toUpperCase()+opt.slice(1)}</option>`;
      }
      html += '</select></div>';
    }
  }
  html += '</div><div class="btn-row"><button class="btn btn-primary" onclick="draw()">ğŸ”„ Regenerate</button><button class="btn btn-secondary" onclick="resetParams()">Reset Defaults</button></div>';
  controlsDiv.innerHTML = html;

  // Info panel
  document.getElementById('info').innerHTML = `<h3>${cfg.info.title}</h3>${cfg.info.html}`;

  // Knowledge links
  renderKnowledgeLinks(id);

  resize();
}

function setParam(id, value, dflt) {
  const num = parseFloat(value);
  params[id] = isNaN(num) ? value : num;
  const valSpan = document.getElementById('val_' + id);
  if (valSpan) valSpan.textContent = value;
  draw();
}

function resetParams() {
  const cfg = catConfigs[currentCat];
  if (!cfg) return;
  for (const c of cfg.controls) {
    if (c.default !== undefined) params[c.id] = c.default;
  }
  loadCategory(currentCat);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Init
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
buildNav();
loadCategory('phyllotaxis');
</script>
</body>
</html>
